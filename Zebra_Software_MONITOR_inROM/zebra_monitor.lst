ca65 V2.18 - Ubuntu 2.18-1
Main file   : zebra_monitor.s
Current file: zebra_monitor.s

000000r 1               ;  The Mai Monitor for Zebra Homebrew Computer
000000r 1               ;  Written by @Earture in 2021 modified by
000000r 1               
000000r 1               
000000r 1               ; Lines with comments starting with "*" indicate code changes from the original WozMon.
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               KBD         = $8001          ; PIA.A keyboard input
000000r 1               KBDCR       = $8011
000000r 1               DSP         = $8002          ; PIA.B display output register
000000r 1               DSPCR       = $8012
000000r 1               
000000r 1               ; Page 0 Variables
000000r 1               
000000r 1               IN          = $0200          ;*Input buffer
000000r 1               XAML        = $24            ;*Index pointers
000000r 1               XAMH        = $25
000000r 1               STL         = $26
000000r 1               STH         = $27
000000r 1               L           = $28
000000r 1               H           = $29
000000r 1               YSAV        = $2A
000000r 1               MODE        = $2B
000000r 1               MSGL        = $2C
000000r 1               MSGH        = $2D
000000r 1               COUNTER     = $2E
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1                          .org $ED80
00ED80  1               
00ED80  1               
00ED80  1  D8           RESET:      CLD             ; Clear decimal arithmetic mode.
00ED81  1  58                       CLI
00ED82  1               
00ED82  1               
00ED82  1               
00ED82  1  A9 FF                    LDA #$FF        ; clear screen
00ED84  1  8D 20 80                 STA $8020
00ED87  1               
00ED87  1               
00ED87  1               
00ED87  1  A9 22                    LDA #<MSG1
00ED89  1  85 2C                    STA MSGL
00ED8B  1  A9 EF                    LDA #>MSG1
00ED8D  1  85 2D                    STA MSGH
00ED8F  1  20 FB EE                 JSR SHWMSG      ;* Show Welcome.
00ED92  1                           ;LDA #$0A
00ED92  1                           ;JSR ECHO        ;* New line.
00ED92  1  A9 9B        SOFTRESET:  LDA #$9B        ;* Auto escape.
00ED94  1  C9 88        NOTCR:      CMP #$88        ;* "<-"? Note this was changed to $88 which is the back space key.
00ED96  1  F0 27                    BEQ BACKSPACE   ; Yes.
00ED98  1  C9 9B                    CMP #$9B        ; ESC?
00ED9A  1  F0 03                    BEQ ESCAPE      ; Yes.
00ED9C  1  C8                       INY             ; Advance text index.
00ED9D  1  10 2D                    BPL NEXTCHAR    ; Auto ESC if >127.
00ED9F  1  A9 52        ESCAPE:     LDA #$52        ; "R"
00EDA1  1  20 CB EE                 JSR ECHO        ; Output it.
00EDA4  1  A9 65                    LDA #$65        ; "e"
00EDA6  1  20 CB EE                 JSR ECHO        ; Output it.
00EDA9  1  A9 61                    LDA #$61        ; "a"
00EDAB  1  20 CB EE                 JSR ECHO        ; Output it.
00EDAE  1  A9 64                    LDA #$64        ; "d"
00EDB0  1  20 CB EE                 JSR ECHO        ; Output it.
00EDB3  1  A9 79                    LDA #$79        ; "y"
00EDB5  1  20 CB EE                 JSR ECHO        ; Output it.
00EDB8  1  A9 0A        GETLINE:    LDA #$0A        ; CR.
00EDBA  1  20 CB EE                 JSR ECHO        ; Output it.
00EDBD  1  A0 01                    LDY #$01        ; Initiallize text index.
00EDBF  1  88           BACKSPACE:  DEY             ; Backup text index.
00EDC0  1  30 F6                    BMI GETLINE     ; Beyond start of line, reinitialize.
00EDC2  1  A9 A0                    LDA #$A0        ;*Space, overwrite the backspaced char.
00EDC4  1  20 CB EE                 JSR ECHO
00EDC7  1  A9 FF                    LDA #$FF        ;*Backspace again to get to correct pos.========================
00EDC9  1  20 CB EE                 JSR ECHO
00EDCC  1               
00EDCC  1               
00EDCC  1               NEXTCHAR:
00EDCC  1  AD 01 80                 LDA KBD         ; Load character. B7 should be ‘1’.
00EDCF  1  C9 00                    CMP #$00
00EDD1  1  F0 F9                    BEQ NEXTCHAR
00EDD3  1               
00EDD3  1  C9 60                    CMP #$60        ;*Is it Lower case
00EDD5  1  30 02                    BMI   CONVERT   ;*Nope, just convert it
00EDD7  1  29 5F                    AND #$5F        ;*If lower case, convert to Upper case
00EDD9  1  09 80        CONVERT:    ORA #$80        ;*Convert it to "ASCII Keyboard" Input
00EDDB  1  99 00 02                 STA IN,Y        ; Add to text buffer.
00EDDE  1  20 CB EE                 JSR ECHO        ; Display character.
00EDE1  1  C9 8D                    CMP #$8D        ; CR?
00EDE3  1  D0 AF                    BNE NOTCR       ; No.
00EDE5  1  A0 FF                    LDY #$FF        ; Reset text index.
00EDE7  1  A9 00                    LDA #$00        ; For XAM mode.
00EDE9  1  AA                       TAX             ; 0->X.
00EDEA  1  0A           SETSTOR:    ASL             ; Leaves $7B if setting STOR mode.
00EDEB  1  85 2B        SETMODE:    STA MODE        ; $00 = XAM, $7B = STOR, $AE = BLOK XAM.
00EDED  1  C8           BLSKIP:     INY             ; Advance text index.
00EDEE  1  B9 00 02     NEXTITEM:   LDA IN,Y        ; Get charcter.
00EDF1  1  C9 8D                    CMP #$8D        ; CR?
00EDF3  1  F0 C3                    BEQ GETLINE     ; Yes, done this line.
00EDF5  1  C9 AE                    CMP #$AE        ; "."?
00EDF7  1  90 F4                    BCC BLSKIP      ; Skip delimiter.
00EDF9  1  F0 F0                    BEQ SETMODE     ; Set BLOCK XAM mode.
00EDFB  1  C9 BA                    CMP #$BA        ; ":"?
00EDFD  1  F0 EB                    BEQ SETSTOR     ; Yes, set STOR mode.
00EDFF  1  C9 D2                    CMP #$D2        ; "R"?
00EE01  1  F0 41                    BEQ RUN         ; Yes, run user program.  =================================================menu
00EE03  1  C9 CB                    CMP #'K'+$80   ;
00EE05  1  F0 49                    BEQ ZEBRA_ASS       ;
00EE07  1  C9 C9                    CMP #'I'+$80   ;
00EE09  1  F0 4B                    BEQ LOGO
00EE0B  1  C9 CD                    CMP #'M'+$80   ; msbasic
00EE0D  1  F0 50                    BEQ MSBASIC
00EE0F  1  C9 D8                    CMP #'X'+$80   ; user program
00EE11  1  F0 46                    BEQ USER_FUNC
00EE13  1  C9 D6                    CMP #'V'+$80   ; color
00EE15  1  F0 45                    BEQ MY_COLOR
00EE17  1               
00EE17  1               
00EE17  1               
00EE17  1  86 28                    STX L           ; $00->L.
00EE19  1  86 29                    STX H           ; and H.
00EE1B  1  84 2A                    STY YSAV        ; Save Y for comparison.
00EE1D  1  B9 00 02     NEXTHEX:     LDA IN,Y       ; Get character for hex test.
00EE20  1  49 B0                    EOR #$B0        ; Map digits to $0-9.                        B0: 1011 0000
00EE22  1  C9 0A                    CMP #$0A        ; Digit?
00EE24  1  90 06                    BCC DIG         ; Yes.
00EE26  1  69 88                    ADC #$88        ; Map letter "A"-"F" to $FA-FF.
00EE28  1  C9 FA                    CMP #$FA        ; Hex letter?
00EE2A  1  90 11                    BCC NOTHEX      ; No, character not hex.
00EE2C  1  0A           DIG:        ASL
00EE2D  1  0A                       ASL             ; Hex digit to MSD of A.
00EE2E  1  0A                       ASL
00EE2F  1  0A                       ASL
00EE30  1  A2 04                    LDX #$04        ; Shift count.
00EE32  1  0A           HEXSHIFT:   ASL             ; Hex digit left MSB to carry.
00EE33  1  26 28                    ROL L           ; Rotate into LSD.
00EE35  1  26 29                    ROL H           ; Rotate into MSD's.
00EE37  1  CA                       DEX             ; Done 4 shifts?
00EE38  1  D0 F8                    BNE HEXSHIFT    ; No, loop.
00EE3A  1  C8                       INY             ; Advance text index.
00EE3B  1  D0 E0                    BNE NEXTHEX     ; Always taken. Check next character for hex.
00EE3D  1  C4 2A        NOTHEX:     CPY YSAV        ; Check if L, H empty (no hex digits).
00EE3F  1  D0 21                    BNE NOESCAPE    ;* Branch out of range, had to improvise...
00EE41  1  4C 9F ED                 JMP ESCAPE      ; Yes, generate ESC sequence.
00EE44  1               
00EE44  1  20 4A EE     RUN:        JSR ACTRUN      ;* JSR to the Address we want to run.
00EE47  1  4C 92 ED                 JMP   SOFTRESET ;* When returned for the program, reset EWOZ.
00EE4A  1  6C 24 00     ACTRUN:     JMP (XAML)      ; Run at current XAM index.
00EE4D  1               
00EE4D  1               
00EE4D  1               
00EE4D  1  4C D3 EE     ZEBRA_CLS:  JMP ZEBRA_CLS1
00EE50  1               
00EE50  1               ZEBRA_ASS:
00EE50  1  20 4D EE                 JSR ZEBRA_CLS
00EE53  1  4C 00 F0                 JMP $F000
00EE56  1               
00EE56  1  4C 08 EF     LOGO:       JMP LOGO1
00EE59  1               
00EE59  1  4C DB EE     USER_FUNC:  JMP USER_FUNC1
00EE5C  1  4C DE EE     MY_COLOR:  JMP MY_COLOR1
00EE5F  1  4C F5 EE     MSBASIC:    JMP MSBASIC1
00EE62  1               
00EE62  1  24 2B        NOESCAPE:   BIT MODE        ; Test MODE byte.
00EE64  1  50 0D                    BVC NOTSTOR     ; B6=0 for STOR, 1 for XAM and BLOCK XAM
00EE66  1  A5 28                    LDA L           ; LSD's of hex data.
00EE68  1  81 26                    STA (STL, X)    ; Store at current "store index".
00EE6A  1  E6 26                    INC STL         ; Increment store index.
00EE6C  1  D0 80                    BNE NEXTITEM    ; Get next item. (no carry).
00EE6E  1  E6 27                    INC STH         ; Add carry to 'store index' high order.
00EE70  1  4C EE ED     TONEXTITEM: JMP NEXTITEM    ; Get next command item.
00EE73  1  30 2B        NOTSTOR:    BMI XAMNEXT     ; B7=0 for XAM, 1 for BLOCK XAM.
00EE75  1  A2 02                    LDX #$02        ; Byte count.
00EE77  1  B5 27        SETADR:     LDA L-1,X       ; Copy hex data to
00EE79  1  95 25                    STA STL-1,X     ; "store index".
00EE7B  1  95 23                    STA XAML-1,X    ; And to "XAM index'.
00EE7D  1  CA                       DEX             ; Next of 2 bytes.
00EE7E  1  D0 F7                    BNE SETADR      ; Loop unless X = 0.
00EE80  1  D0 14        NXTPRNT:    BNE PRDATA      ; NE means no address to print.
00EE82  1  A9 0A                    LDA #$0A        ; CR.
00EE84  1  20 CB EE                 JSR ECHO        ; Output it.
00EE87  1  A5 25                    LDA XAMH        ; 'Examine index' high-order byte.
00EE89  1  20 B8 EE                 JSR PRBYTE      ; Output it in hex format.
00EE8C  1  A5 24                    LDA XAML        ; Low-order "examine index" byte.
00EE8E  1  20 B8 EE                 JSR PRBYTE      ; Output it in hex format.
00EE91  1  A9 BA                    LDA #$BA        ; ":".
00EE93  1  20 CB EE                 JSR ECHO        ; Output it.
00EE96  1  A9 A0        PRDATA:     LDA #$A0        ; Blank.
00EE98  1  20 CB EE                 JSR ECHO        ; Output it.
00EE9B  1  A1 24                    LDA (XAML,X)    ; Get data byte at 'examine index".
00EE9D  1  20 B8 EE                 JSR PRBYTE      ; Output it in hex format.
00EEA0  1  86 2B        XAMNEXT:    STX MODE        ; 0-> MODE (XAM mode).
00EEA2  1  A5 24                    LDA XAML
00EEA4  1  C5 28                    CMP L           ; Compare 'examine index" to hex data.
00EEA6  1  A5 25                    LDA XAMH
00EEA8  1  E5 29                    SBC H
00EEAA  1  B0 C4                    BCS TONEXTITEM  ; Not less, so no more data to output.
00EEAC  1  E6 24                    INC XAML
00EEAE  1  D0 02                    BNE MOD8CHK     ; Increment 'examine index".
00EEB0  1  E6 25                    INC XAMH
00EEB2  1  A5 24        MOD8CHK:    LDA XAML        ; Check low-order 'exainine index' byte
00EEB4  1  29 03                    AND #$03        ; For MOD 8=0 ** changed to $0F to get 16 values per row **
00EEB6  1  10 C8                    BPL NXTPRNT     ; Always taken.
00EEB8  1  48           PRBYTE:     PHA             ; Save A for LSD.
00EEB9  1  4A                       LSR
00EEBA  1  4A                       LSR
00EEBB  1  4A                       LSR             ; MSD to LSD position.
00EEBC  1  4A                       LSR
00EEBD  1  20 C1 EE                 JSR PRHEX       ; Output hex digit.
00EEC0  1  68                       PLA             ; Restore A.
00EEC1  1  29 0F        PRHEX:      AND #$0F        ; Mask LSD for hex print.
00EEC3  1  09 B0                    ORA #$B0        ; Add "0".
00EEC5  1  C9 BA                    CMP #$BA        ; Digit?
00EEC7  1  90 02                    BCC ECHO        ; Yes, output it.
00EEC9  1  69 06                    ADC #$06        ; Add offset for letter.
00EECB  1  48           ECHO:       PHA             ;*Save A
00EECC  1  29 7F                    AND #$7F        ;*Change to "standard ASCII"
00EECE  1               
00EECE  1               
00EECE  1  8D 02 80                 STA DSP         ; Output character. Sets DA.
00EED1  1               
00EED1  1  68                       PLA             ;*Restore A
00EED2  1  60                       RTS             ;*Done, over and out...
00EED3  1               
00EED3  1               ZEBRA_CLS1:
00EED3  1  48                       PHA
00EED4  1  A9 FF                    LDA #$FF        ; clear screen
00EED6  1  8D 20 80                 STA $8020
00EED9  1  68                       PLA
00EEDA  1  60                       RTS
00EEDB  1               
00EEDB  1               USER_FUNC1:
00EEDB  1               
00EEDB  1  4C 00 90                 JMP  $9000
00EEDE  1               
00EEDE  1               
00EEDE  1               MY_COLOR1:
00EEDE  1  A9 1F                    LDA  #$1F
00EEE0  1  8D 0D 71                 STA  $710D
00EEE3  1  A9 90                    LDA  #$90
00EEE5  1  8D 0E 71                 STA  $710E
00EEE8  1  A9 0E                    LDA  #$0E
00EEEA  1  8D 0F 71                 STA  $710F
00EEED  1  A9 01                    LDA  #$01
00EEEF  1  8D 05 80                 STA  $8005
00EEF2  1  4C 92 ED                 JMP  SOFTRESET
00EEF5  1               
00EEF5  1               MSBASIC1:
00EEF5  1  20 4D EE                 JSR ZEBRA_CLS
00EEF8  1  4C 58 DF                 JMP $DF58
00EEFB  1               
00EEFB  1               
00EEFB  1               
00EEFB  1  A0 00        SHWMSG:     LDY #$0
00EEFD  1  B1 2C        PRINT:      LDA (MSGL),Y
00EEFF  1  F0 06                    BEQ DONE
00EF01  1  20 CB EE                 JSR ECHO
00EF04  1  C8                       INY
00EF05  1  D0 F6                    BNE PRINT
00EF07  1  60           DONE:       RTS
00EF08  1               
00EF08  1  A9 FF        LOGO1:      LDA #$FF
00EF0A  1  8D 20 80                 STA $8020
00EF0D  1  A9 4B                    LDA #<MSG2
00EF0F  1  85 2C                    STA MSGL
00EF11  1  A9 EF                    LDA #>MSG2
00EF13  1  85 2D                    STA MSGH
00EF15  1  20 FB EE                 JSR SHWMSG
00EF18  1  AD 01 80     LOGO_LP:    LDA KBD
00EF1B  1  C9 00                    CMP #$00
00EF1D  1  F0 F9                    BEQ LOGO_LP
00EF1F  1  4C 80 ED                 JMP RESET
00EF22  1               
00EF22  1               
00EF22  1               
00EF22  1  2A 2A 20 5A  MSG1:      .byte "** Zebra Monitor **    32K RAM System   ",0
00EF26  1  65 62 72 61  
00EF2A  1  20 4D 6F 6E  
00EF4B  1                                ;123456789ABCDEFGHIJK123456789ABCDEFGHIJK
00EF4B  1               MSG2:      ;.byte "^^^^^^^^^^^^^^^^^^^^"
00EF4B  1  2A 20 20 20             .byte "*       (>_^)      *"
00EF4F  1  20 20 20 20  
00EF53  1  28 3E 5F 5E  
00EF5F  1  2A 20 20 20             .byte "*                  *"
00EF63  1  20 20 20 20  
00EF67  1  20 20 20 20  
00EF73  1  2A 20 20 20             .byte "*       Zebra      *"
00EF77  1  20 20 20 20  
00EF7B  1  5A 65 62 72  
00EF87  1  2A 20 20 20             .byte "*       v1.00      *"
00EF8B  1  20 20 20 20  
00EF8F  1  76 31 2E 30  
00EF9B  1  2A 20 20 20             .byte "*                  *"
00EF9F  1  20 20 20 20  
00EFA3  1  20 20 20 20  
00EFAF  1  2A 20 48 6F             .byte "* HomebrewComputer *"
00EFB3  1  6D 65 62 72  
00EFB7  1  65 77 43 6F  
00EFC3  1  2A 20 20 20             .byte "*                  *"
00EFC7  1  20 20 20 20  
00EFCB  1  20 20 20 20  
00EFD7  1  2A 20 20 20             .byte "*      Earture     *"
00EFDB  1  20 20 20 45  
00EFDF  1  61 72 74 75  
00EFEB  1  2A 20 20 20             .byte "*                  *",0
00EFEF  1  20 20 20 20  
00EFF3  1  20 20 20 20  
00F000  1                          ;.byte "^^^^^^^^^^^^^^^^^^^",0
00F000  1               
00F000  1               
00F000  1               
